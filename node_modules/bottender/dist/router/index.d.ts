import Context from '../context/Context';
import line from '../line/routes';
import messenger from '../messenger/routes';
import slack from '../slack/routes';
import telegram from '../telegram/routes';
import viber from '../viber/routes';
import { Action, Client, Event, Props } from '../types';
declare type MatchPattern = string | Array<string> | RegExp;
declare type RoutePattern<C extends Client, E extends Event> = '*' | RoutePredicate<C, E>;
export declare type RoutePredicate<C extends Client, E extends Event> = (context: Context<C, E>) => boolean | Record<string, any> | Promise<boolean | Record<string, any>>;
declare type Route<C extends Client, E extends Event> = {
    predicate: RoutePredicate<C, E>;
    action: Action<C, E>;
};
declare function router<C extends Client = any, E extends Event = any>(routes: Route<C, E>[]): (context: Context<C, E>, props?: Props<C, E>) => Promise<Action<C, E> | undefined>;
declare function route<C extends Client = any, E extends Event = any>(pattern: RoutePattern<C, E>, action: Action<C, E>): {
    predicate: RoutePredicate<C, E>;
    action: Action<C, E>;
};
declare function text<C extends Client = any, E extends Event = any>(pattern: MatchPattern, action: Action<C, E>): {
    predicate: (context: Context<C, E>) => any;
    action: Action<C, E>;
};
declare function payload<C extends Client = any, E extends Event = any>(pattern: MatchPattern, action: Action<C, E>): {
    predicate: (context: Context<C, E>) => any;
    action: Action<C, E>;
};
declare function platform<C extends Client = any, E extends Event = any>(pattern: MatchPattern, action: Action<C, E>): {
    predicate: (context: Context<C, E>) => boolean;
    action: Action<C, E>;
} | {
    predicate: (context: Context<C, E>) => RegExpExecArray | null;
    action: Action<C, E>;
};
export default router;
export { router, route, text, payload, platform, line, messenger, slack, telegram, viber, };
//# sourceMappingURL=index.d.ts.map